# vim: syntax=python tabstop=4 expandtab
# coding: utf-8

from os import path
from Bio.Seq import Seq
import pandas as pd
import scripts.lib.common.constants as constants
from datetime import datetime

def sample_id(wildcards):
    """

    >>> import types
    >>> wildcards = types.SimpleNamespace()
    >>> wildcards.sample = '/path/to/sample'
    >>> sample_id(wildcards)
    'sample'
    """
    return path.split(wildcards.sample)[-1]

def reverse_complement(sequence):
    """
    >>> reverse_complement("ACGCT")
    'AGCGT'
    """
    return str(Seq(sequence).reverse_complement())

def get_fastq(wildcards, units, read_pair='fq1'):
    return units.loc[(path.split(wildcards.sample)[-1], wildcards.unit), [read_pair]].dropna()[0]

def get_fastq_files(wildcards, samples, read_pair="fq1"):
    """
    Return the expected fastq file path.

    Parameters
    ----------
    wildcards: wildcard object generated by snakemake
    samples: dict with trimming information
    read_pair: string defining read pair, "fq1" or "fq"2, default is "fq1"

    >>> import types
    >>> wildcards = types.SimpleNamespace()
    >>> wildcards.sample = "sample0"
    >>> samples = {'trimming': {'sample1': 'cutadapt', 'sample2': 'swift'}, 'fq1': {'sample0': "sample.fastq.gz"}}
    >>> get_fastq_files(wildcards, samples)
    'sample.fastq.gz'
    >>> wildcards.sample = "sample1"
    >>> wildcards.unit = "lane1"
    >>> get_fastq_files(wildcards, samples)
    'sample1-lane1.R1.cutadapt.fastq.gz'
    >>> get_fastq_files(wildcards, samples, "fq2")
    'sample1-lane1.R2.cutadapt.fastq.gz'
    >>> wildcards.sample = "sample2"
    >>> wildcards.unit = "lane2"
    >>> get_fastq_files(wildcards, samples)
    'sample2-lane2.R1.trimmomatic_cutadapt.fastq.gz'
    >>> get_fastq_files(wildcards, samples, "fq2")
    'sample2-lane2.R2.trimmomatic_cutadapt.fastq.gz'
    """
    trimming = samples.get("trimming",{}).get(wildcards.sample)
    if trimming is None or pd.isnull(trimming): #Write test for isnull
        return samples[read_pair][wildcards.sample]
    else:
        return wildcards.sample + "." + wildcards.unit + "." + constants.trimming[trimming][read_pair]

def get_bam_file(wildcards, samples, use_default=False):
    """
    Return the expected bam file path.

    Parameters
    ----------
    wildcards: wildcard object generated by snakemake
    samples: dict with panel information

    >>> import types
    >>> wildcards = types.SimpleNamespace()
    >>> wildcards.sample = "sample0"
    >>> samples = {'panel_type': {'sample0': 'haloplex', 'sample1': 'swift'}}
    >>> get_bam_file(wildcards, samples)
    'sample0.amplicon_annotated.sorted.bam'
    >>> wildcards.sample = "sample1"
    >>> get_bam_file(wildcards, samples)
    'sample1.sorted.bam'
    >>> wildcards.sample = "sample2"
    >>> get_bam_file(wildcards, samples)
    'sample2.sorted.bam'
    """
    panel_type = samples.get("panel_type",{}).get(wildcards.sample)
    if panel_type is None or pd.isnull(panel_type) or use_default: #Write test for isnull
        return wildcards.sample + "." + constants.bam_file_ending['default']
    else:
        return wildcards.sample + "." + constants.bam_file_ending[panel_type]


def get_now():
    return datetime.now().strftime('%Y%m%d')

if __name__ == "__main__":
    import doctest
    import logging
    import sys
    logging.basicConfig(level=logging.CRITICAL, stream=sys.stdout, format='%(message)s')
    result = doctest.testmod()
    sys.exit(result.failed)
